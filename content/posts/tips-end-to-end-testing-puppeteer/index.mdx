---
title: "Tips for End to End Testing with Puppeteer"
subtitle: "Getting up to speed with Puppeteer!"
date: 2020-06-07
slug: "/blog/tips-end-to-end-testing-puppeteer/"
tags:
  - JavaScript
  - Software Testing
---

import Accordion from "../components/Accordion";
import Caption from "../components/Caption";
import GIF from "../components/GIF";
import ScrollToTopButton from "../components/ScrollToTopButton";

<ScrollToTopButton />

These are exciting times for End to End in the JavaScript world. In the last couple of years, tools such as <a href="https://www.cypress.io/" target="_blank" title="JavaScript End to End Testing Framework | cypress.io">cypress</a> and <a href="https://pptr.dev/" target="_blank" title="Puppeteer Official Home">Puppeteer</a> have flooded the JavaScript community and gain a fast adoption.

Today I'm writing about Puppeteer.

I want to share a pragmatic list of tips and resources that can help you get a fast overall understanding of things to consider when using Puppeteer.

**Topics I'll Cover**

1. [Getting things running](#getting-things-running)
2. Writing Tests
3. Debugging
4. Performance Automation
5. Browser Support

#### Getting things running

In this section, I discuss the main aspects of running a test with Puppeteer, including some interoperability aspects that we should consider, such as the eventual usage of an underlying testing library such as Jest.

##### Running tests in parallel

To launch different browser instances to run your test suite, you'll rely on your chosen test runner. For example, with <a href="https://jestjs.io/" target="_blank" title="Jest Â· ðŸƒ Delightful JavaScript Testing">Jest</a>, I leverage the config <a href="https://jestjs.io/docs/en/cli.html#--maxworkersnumstring" target="_blank" title="Max Workers Jest Documentation">maxWorkers</a> to define how many browser sessions I allow to run concurrently.

##### Be aware of the global timeout value

You want to increase the value of the test timeout. End to end tests might take up several seconds to run. If you're using Jest, you can configure the timeout value with the property <a href="https://jestjs.io/docs/en/configuration#testtimeout-number" target="_blank" title="testTimeout Jest Documentation">testTimeout</a>, which for Jest 26.0 defaults to 5 seconds.

Here's an example of my `jest.config.js` with the mentioned configurations.

```javascript:title=jest.config.js
module.exports = {
  verbose: true,
  rootDir: ".",
  testTimeout: 30000,
  maxWorkers: 3,
};
```

Another example is if you're using <a href="https://jestjs.io/docs/en/configuration#testtimeout-number" target="_blank" title="Mocha - the fun, simple, flexible JavaScript test framework">mocha</a>, you can add `this.timeout(VALUE_IN_SECONDS);` at the top level of your `describe` block.

<br />

##### Abstracting puppeteer.launch

To bootstrap your test, you have to run <a href="https://pptr.dev/#?product=Puppeteer&version=v3.1.0&show=api-puppeteerlaunchoptions" target="_blank" title="puppeteer.launch Documentation">puppeteer.lauch</a>. I recommend you to be abstract this call within a custom function. Doing so allows you to customize everything about how the environment each different test window/session individually. I'm referring to making the following things **configurable**:

- Allow the client to specify what page the browser should navigate first
- Allow the client to decide under what **network conditions** the test runs. I'll [also cover this in this article](#throttling-network-connection-speed).
- Allow the client to specify things like whether the <a href="https://pptr.dev/#?product=Puppeteer&version=v3.1.0&show=api-puppeteerlaunchoptions" target="_blank" title="puppeteer.launch Documentation">DevTools</a> are open or the **slowMo** (also included in this article). It could be quite handy to narrow down these configurations to a particular test in your test suite.

```javascript:title=boot.js
import puppeteer from "puppeteer";

export default async function boot(options = {}) {
  let page = null;
  let browser = null;

  const { goToTargetApp = true, headless = true, devtools = false, slowMo = false } = options;

  browser = await puppeteer.launch({
    headless,
    devtools,
    ...(slowMo && { slowMo }),
  });

  if (goToTargetApp) {
    page = await browser.newPage();
    // I'm assuming there's some environment variable here
    // that points towards the app we're going to test
    await page.goto(process.env.APP_URL);
  }

  return { page };
}
```

I like to have my launch function just dealing with the bootstrap configuration aspects of my test environment and launch the application. I try to keep it as slimmer as possible, but sometimes I feel the urge to add more stuff here. There's a saying:

<br />

> "Functions should do one thing. They should do it well. They should do it only."

_source_: <a href="https://www.amazon.com/gp/product/0132350882/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0132350882&linkCode=as2&tag=goodguydaniel-20&linkId=7d43375b6b0cd381f5ce0e61779b6fc5" target="_blank" title="Clean Code: A Handbook of Agile Software Craftsmanship">Clean Code by Robert C. Martin</a>

<br />

##### Throttling Network Connection Speed

If you want to run your tests under different network speed conditions, I got your back. Let me share the pattern I use <a href="https://gist.github.com/trungpv1601/2ccd3cc998149a84ba80ed7a4c9ef562" target="_blank" title="Network throttling in Puppeteer GitHub Gist">based on this gist that I luckily found</a>.

If you [abstract puppeteer.launch](#abstracting-puppeteerlaunch), your test could switch between network presets just by doing the following.

```javascript:title=boot.js
import puppeteer from "puppeteer";
import NETWORK_PRESETS from "./network-presets";

export default async function boot(options = {}) {
  let page = null;
  let browser = null;

  const { goToTargetApp = true, headless = true, devtools = false, slowMo = false } = options;

  browser = await puppeteer.launch({
    headless,
    devtools,
    ...(slowMo && { slowMo }),
  });

  if (goToTargetApp) {
    page = await browser.newPage();
    // I'm assuming there's some environment variable here
    // that points towards the app we're going to test
    await page.goto(`${process.env.TARGET_APP_URL}${targetAppQueryParams}`);

    if (network && NETWORK_PRESETS[network]) {
      // setup custom network speed
      const client = await page.target().createCDPSession();
      await client.send("Network.emulateNetworkConditions", NETWORK_PRESETS[network]);
    }
  }

  return { page };
}
```

<br />

<Accordion summary="network-presets.js">

```javascript:title=network-presets.js
// source: https://gist.github.com/trungpv1601/2ccd3cc998149a84ba80ed7a4c9ef562
export default {
  GPRS: {
    offline: false,
    downloadThroughput: (50 * 1024) / 8,
    uploadThroughput: (20 * 1024) / 8,
    latency: 500,
  },
  Regular2G: {
    offline: false,
    downloadThroughput: (250 * 1024) / 8,
    uploadThroughput: (50 * 1024) / 8,
    latency: 300,
  },
  Good2G: {
    offline: false,
    downloadThroughput: (450 * 1024) / 8,
    uploadThroughput: (150 * 1024) / 8,
    latency: 150,
  },
  Regular3G: {
    offline: false,
    downloadThroughput: (750 * 1024) / 8,
    uploadThroughput: (250 * 1024) / 8,
    latency: 100,
  },
  Good3G: {
    offline: false,
    downloadThroughput: (1.5 * 1024 * 1024) / 8,
    uploadThroughput: (750 * 1024) / 8,
    latency: 40,
  },
  Regular4G: {
    offline: false,
    downloadThroughput: (4 * 1024 * 1024) / 8,
    uploadThroughput: (3 * 1024 * 1024) / 8,
    latency: 20,
  },
  DSL: {
    offline: false,
    downloadThroughput: (2 * 1024 * 1024) / 8,
    uploadThroughput: (1 * 1024 * 1024) / 8,
    latency: 5,
  },
  WiFi: {
    offline: false,
    downloadThroughput: (30 * 1024 * 1024) / 8,
    uploadThroughput: (15 * 1024 * 1024) / 8,
    latency: 2,
  },
};
```

</Accordion>

<br />
<br />

##### Loading a Browser Extension

Here's how to load a browser extension in the browser instance against whom your tests run.

```javascript
// launch puppeeter pass along the extension path within your project
// a relative path that points to the directory you output your extension assets
browser = await puppeteer.launch({
  // extension are allowed only in head-full mode
  headless: false,
  devtools,
  args: [`--disable-extensions-except=${process.env.EXTENSION_PATH}`, `--load-extension=${process.env.EXTENSION_PATH}`],
  ...(slowMo && { slowMo }),
});

// 1. find the extension by the title
// you might want to tackle this differently
// depending on your use case
const targets = await browser.targets();
const extensionTarget = targets.find(({ _targetInfo }) => {
  return _targetInfo.title === "my extension page title";
});

// 2. getting the extensionId from the URL
// if you have a fixed extensionId you can just pass in an
// environment variable with that value, otherwise this works fine
const partialExtensionUrl = extensionTarget._targetInfo.url || "";
const [, , extensionID] = partialExtensionUrl.split("/");
// here the entry point of the extension is an html file called "popup.html"
const extensionPopupHtml = "popup.html";

// 3. open the chrome extension in a new tab
// notice that to properly build the extension URL you need the
// extensionId and the entrypoint resource
extensionPage = await browser.newPage();
extensionUrl = `chrome-extension://${extensionID}/${extensionPopupHtml}`;

await extensionPage.goto(extensionUrl);
```

<br />

If you want to read through about testing chrome extensions with Puppeteer, I recommend this article: <a href="https://gokatz.me/blog/automate-chrome-extension-testing/" target="_blank" title="Automate the UI Testing of your chrome extension - Gokul Kathirvel">Automate the UI Testing of your chrome extension</a> by <a href="https://gokatz.me/" target="_blank" title="Gokul Kathirvel">Gokul Kathirvel</a>.

<br />

#### Writing Tests

Apart from the last subsection, what I discuss next, you can read it in the official documentation. I'm just going to step on those that I consider to be essential bits of the Puppeteer API.

##### Working with page.evaluate

You'll need to get used to the detail that when using the page.evaluate API,you run on the page context,
meaning even if you're using arrow functions as an argument to page.evaluate, you can't refer
to things out of the scope of that function. You need to provide all the data you'll need as the
third argument of page.evaluate. Keep this in mind.

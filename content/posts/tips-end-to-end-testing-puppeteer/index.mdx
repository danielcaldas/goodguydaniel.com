---
title: "Tips for End to End Testing with Puppeteer"
subtitle: "Getting up to speed with Puppeteer!"
date: 2020-06-07
slug: "/blog/tips-end-to-end-testing-puppeteer/"
tags:
  - JavaScript
  - Software Testing
---

import Accordion from "../components/Accordion";
import Caption from "../components/Caption";
import GIF from "../components/GIF";
import ScrollToTopButton from "../components/ScrollToTopButton";

<ScrollToTopButton />

These are exciting times for End to End in the JavaScript world. In the last couple of years, tools such as <a href="https://www.cypress.io/" target="_blank" title="JavaScript End to End Testing Framework | cypress.io">cypress</a> and <a href="https://pptr.dev/" target="_blank" title="Puppeteer Official Home">Puppeteer</a> have flooded the JavaScript community and gain a fast adoption.

Today I'm writing about Puppeteer.

I want to share a pragmatic list of tips and resources that can help you get a fast overall understanding of things to consider when using Puppeteer.

**Topics I'll Cover**

1. Getting things running
2. Writing Tests
3. Debugging
4. Performance Automation
5. Browser Support

#### Getting things running

In this section, I discuss the main aspects of running a test with Puppeteer, including some interoperability aspects that we should consider, such as the eventual usage of an underlying testing library such as Jest.

##### Running tests in parallel

To launch different browser instances to run your test suite, you'll rely on your chosen test runner. For example, with <a href="https://jestjs.io/" target="_blank" title="Jest · 🃏 Delightful JavaScript Testing">Jest</a>, I leverage the config <a href="https://jestjs.io/docs/en/cli.html#--maxworkersnumstring" target="_blank" title="Max Workers Jest Documentation">maxWorkers</a> to define how many browser sessions I allow to run concurrently.

##### Be aware of the global timeout value

You want to increase the value of the test timeout. End to end tests might take up several seconds to run. If you're using Jest, you can configure the timeout value with the property <a href="https://jestjs.io/docs/en/configuration#testtimeout-number" target="_blank" title="testTimeout Jest Documentation">testTimeout</a>, which for Jest 26.0 defaults to 5 seconds.
Another example, if you're using <a href="https://jestjs.io/docs/en/configuration#testtimeout-number" target="_blank" title="Mocha - the fun, simple, flexible JavaScript test framework">mocha</a> you can use `this.timeout(VALUE_IN_SECONDS);` at the top level of your `describe` block.

Here's an example of my `jest.config.js` with the mentioned configurations.

```javascript:title=jest.config.js
module.exports = {
  verbose: true,
  rootDir: ".",
  testTimeout: 30000,
  maxWorkers: 3,
};
```

<br />
<br />

##### Abstracting puppeteer.launch

To bootstrap your test, you have to run <a href="https://pptr.dev/#?product=Puppeteer&version=v3.1.0&show=api-puppeteerlaunchoptions" target="_blank" title="puppeteer.launch Documentation">puppeteer.lauch</a>. I recommend you to be abstract this call within a custom function. Doing so allows you to customize everything about how the environment each different test window/session individually. I'm referring to making the following things **configurable**:

- Allow the client to specify what page the browser should navigate first
- Allow the client to decide under what **network conditions** the test runs. I'll also cover this in this article.
- Allow the client to specify things like whether the <a href="https://pptr.dev/#?product=Puppeteer&version=v3.1.0&show=api-puppeteerlaunchoptions" target="_blank" title="puppeteer.launch Documentation">DevTools</a> are open or the **slowMo** (also included in this article). It could be quite handy to narrow down these configurations to a particular test in your test suite.

```javascript:title=boot.js
import puppeteer from "puppeteer";

export default async function boot(options = {}) {
  let page = null;
  let browser = null;

  const {
    goToTargetApp = true,
    headless = true,
    devtools = false,
    slowMo = false,
  } = options;

  browser = await puppeteer.launch({
    headless,
    devtools,
    ...(slowMo && { slowMo }),
  });

  if (goToTargetApp) {
    page = await browser.newPage();
    // I'm assuming there's some environment variable here
    // that points towards the app we're going to test
    await page.goto(process.env.APP_URL);
  }

  return { page };
}
```

<br />
<br />

##### Throttling Network Connection Speed

```javascript:title=boot.js
import puppeteer from "puppeteer";

import NETWORK_PRESETS from "./network-presets";

export default async function boot(options = {}) {
  let page = null;
  let browser = null;

  const {
    goToTargetApp = true,
    headless = true,
    devtools = false,
    slowMo = false,
  } = options;

  browser = await puppeteer.launch({
    headless,
    devtools,
    ...(slowMo && { slowMo }),
  });

  if (goToTargetApp) {
    page = await browser.newPage();
    // I'm assuming there's some environment variable here
    // that points towards the app we're going to test
    await page.goto(`${process.env.TARGET_APP_URL}${targetAppQueryParams}`);

    if (network && NETWORK_PRESETS[network]) {
      // setup custom network speed
      const client = await page.target().createCDPSession();
      await client.send(
        "Network.emulateNetworkConditions",
        NETWORK_PRESETS[network]
      );
    }
  }

  return { page };
}
```

<br />

<Accordion summary="network-presets.js">

```javascript:title=network-presets.js
// source: https://gist.github.com/trungpv1601/2ccd3cc998149a84ba80ed7a4c9ef562
export default {
  GPRS: {
    offline: false,
    downloadThroughput: (50 * 1024) / 8,
    uploadThroughput: (20 * 1024) / 8,
    latency: 500,
  },
  Regular2G: {
    offline: false,
    downloadThroughput: (250 * 1024) / 8,
    uploadThroughput: (50 * 1024) / 8,
    latency: 300,
  },
  Good2G: {
    offline: false,
    downloadThroughput: (450 * 1024) / 8,
    uploadThroughput: (150 * 1024) / 8,
    latency: 150,
  },
  Regular3G: {
    offline: false,
    downloadThroughput: (750 * 1024) / 8,
    uploadThroughput: (250 * 1024) / 8,
    latency: 100,
  },
  Good3G: {
    offline: false,
    downloadThroughput: (1.5 * 1024 * 1024) / 8,
    uploadThroughput: (750 * 1024) / 8,
    latency: 40,
  },
  Regular4G: {
    offline: false,
    downloadThroughput: (4 * 1024 * 1024) / 8,
    uploadThroughput: (3 * 1024 * 1024) / 8,
    latency: 20,
  },
  DSL: {
    offline: false,
    downloadThroughput: (2 * 1024 * 1024) / 8,
    uploadThroughput: (1 * 1024 * 1024) / 8,
    latency: 5,
  },
  WiFi: {
    offline: false,
    downloadThroughput: (30 * 1024 * 1024) / 8,
    uploadThroughput: (15 * 1024 * 1024) / 8,
    latency: 2,
  },
};
```

</Accordion>

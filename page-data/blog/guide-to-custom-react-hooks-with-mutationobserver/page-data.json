{"componentChunkName":"component---src-lekoarts-gatsby-theme-minimal-blog-core-templates-post-query-tsx","path":"/blog/guide-to-custom-react-hooks-with-mutationobserver","result":{"data":{"post":{"__typename":"MdxPost","slug":"/blog/guide-to-custom-react-hooks-with-mutationobserver","title":"Guide to custom React Hooks","date":"21.07.2021","tags":[{"name":"JavaScript","slug":"java-script"},{"name":"React","slug":"react"}],"description":null,"canonicalUrl":"https://blog.logrocket.com/guide-to-custom-react-hooks-with-mutationobserver/","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Guide to custom React Hooks\",\n  \"subtitle\": \"with MutationObserver\",\n  \"canonicalUrl\": \"https://blog.logrocket.com/guide-to-custom-react-hooks-with-mutationobserver/\",\n  \"date\": \"2021-07-21T00:00:00.000Z\",\n  \"slug\": \"/blog/guide-to-custom-react-hooks-with-mutationobserver\",\n  \"tags\": [\"JavaScript\", \"React\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(ScrollToTopButton, {\n    mdxType: \"ScrollToTopButton\"\n  }), mdx(\"p\", null, \"This article was originally published by \", mdx(\"a\", {\n    href: \"https://logrocket.com/\",\n    target: \"_blank\",\n    title: \"LogRocket Modern Frontend Monitoring and Product Analytics\"\n  }, \"LogRocket\"), \". You can checkout the original post \", mdx(\"a\", {\n    href: \"https://blog.logrocket.com/guide-to-custom-react-hooks-with-mutationobserver/\",\n    target: \"_blank\",\n    title: \"Guide to custom React Hooks with MutationObserver LogRocket Blog\"\n  }, \"here\"), \".\"), mdx(\"hr\", null), mdx(\"p\", null, \"With the introduction of React Hooks, the amount of shareable code within React codebases has exploded. Because Hooks are thin APIs on top of React, developers can collaborate by attaching reusable behavior to components and segregating these behaviors into smaller modules.\"), mdx(\"p\", null, \"While this is similar to how JavaScript developers abstract business logic away in vanilla JavaScript modules, Hooks provide more than pure JavaScript functions. Instead of taking data in and out, developers can stretch the spectrum of possibilities of what can happen inside a Hook.\"), mdx(\"p\", null, \"For instance, developers can:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mutate and manage a piece of state for a specific component or an entire application\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Trigger side effects on a page, like changing the title of a browser tab\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Rectify external APIs by tapping into React components\\u2019 lifecycle with Hooks\")), mdx(\"p\", null, \"In this post we\\u2019ll explore the latter possibility. As a case study, we\\u2019ll abstract the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MutationObserver\"), \" API in a custom React Hook, demonstrating how we can build robust, shareable pieces of logic in a React codebase.\"), mdx(\"p\", null, \"We\\u2019ll create a dynamic label that updates itself to indicate how many items we have in a list. Instead of using the provided React state array of elements, we\\u2019ll use the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\"\n  }, \"MutationObserver API\"), \" to detect added elements and update the label accordingly.\"), mdx(GIF, {\n    name: \"react-hooks-fruits-example\",\n    alt: \"Update the dynamic label to count the number of fruits in the list\",\n    mdxType: \"GIF\"\n  }), mdx(Caption, {\n    gif: true,\n    source: \"https://blog.logrocket.com/guide-to-custom-react-hooks-with-mutationobserver/\",\n    mdxType: \"Caption\"\n  }), mdx(\"h2\", {\n    \"id\": \"implementation-overview\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Implementation overview\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#implementation-overview\",\n    \"aria-label\": \"implementation overview permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"style\": {\n      \"paddingLeft\": \"12px\"\n    },\n    \"width\": \"28\",\n    \"height\": \"16\",\n    \"fill\": \"#9f7aea\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The following code is a simple component that renders our list. It also updates a counter value that represents the number of fruits currently in the list:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"export default function App() {\\n  const listRef = useRef();\\n  const [count, setCount] = useState(2);\\n  const [fruits, setFruits] = useState([\\\"apple\\\", \\\"peach\\\"]);\\n  const onListMutation = useCallback(\\n    (mutationList) => {\\n      setCount(mutationList[0].target.children.length);\\n    },\\n    [setCount],\\n  );\\n\\n  useMutationObservable(listRef.current, onListMutation);\\n\\n  return (\\n    <div>\\n      <span>{`Added ${count} fruits`}</span>\\n      <br />\\n      <button onClick={() => setFruits([...fruits, `random fruit ${fruits.length}`])}>Add random fruit</button>\\n      <ul ref={listRef}>\\n        {fruits.map((f) => (\\n          <li key={f}>{f}</li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"We want to trigger a callback function whenever our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \" element is mutated. Within the callback we refer to, the element\\u2019s children give us the number of elements in the list.\"), mdx(\"h2\", {\n    \"id\": \"implementing-the-usemutationobservable-custom-hook\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Implementing the \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"useMutationObservable\"), \" custom Hook\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#implementing-the-usemutationobservable-custom-hook\",\n    \"aria-label\": \"implementing the usemutationobservable custom hook permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"style\": {\n      \"paddingLeft\": \"12px\"\n    },\n    \"width\": \"28\",\n    \"height\": \"16\",\n    \"fill\": \"#9f7aea\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Let\\u2019s look at the integration point:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"useMutationObservable(listRef.current, onListMutation);\\n\")), mdx(\"p\", null, \"The above \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMutationObservable\"), \" custom Hook abstracts the necessary operations to observe changes on the element passed as the first parameter. It then runs the callback passed as the second parameter whenever the target element changes.\"), mdx(\"p\", null, \"Now, let\\u2019s implement our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMutationObservable\"), \" custom Hook.\"), mdx(\"p\", null, \"In the Hook, there are a number of boilerplate operations to understand. First, we must provide a set of options that comply with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MutationObserver\"), \" API.\"), mdx(\"p\", null, \"Once a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MutationObserver\"), \" instance is created, we must call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"observe\"), \" to listen for changes in the targeted DOM element.\"), mdx(\"p\", null, \"When we no longer need to listen to the changes, we must call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"disconnect\"), \" on the observer to clean up our subscription. This must happen when the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component unmounts:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const DEFAULT_OPTIONS = {\\n  config: { attributes: true, childList: true, subtree: true },\\n};\\nfunction useMutationObservable(targetEl, cb, options = DEFAULT_OPTIONS) {\\n  const [observer, setObserver] = useState(null);\\n\\n  useEffect(() => {\\n    const obs = new MutationObserver(cb);\\n    setObserver(obs);\\n  }, [cb, options, setObserver]);\\n\\n  useEffect(() => {\\n    if (!observer) return;\\n    const { config } = options;\\n    observer.observe(targetEl, config);\\n    return () => {\\n      if (observer) {\\n        observer.disconnect();\\n      }\\n    };\\n  }, [observer, targetEl, options]);\\n}\\n\")), mdx(\"p\", null, \"All the above work, including initializing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MutationObserver\"), \" with the right parameters, observing changes with the call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"observer.observe\"), \", and cleaning up with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"observer.disconnect\"), \", are abstracted away from the client.\"), mdx(\"p\", null, \"Not only do we export functionality, but we also clean up by hooking into the React components\\u2019 lifecycle and by leveraging cleanup callbacks on effect Hooks to tear down the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MutationObserver\"), \" instance.\"), mdx(\"p\", null, \"Now that we have a functional and basic version of our Hook, we can think about improving its quality by iterating on its API and enhancing the developer experience around this shareable piece of code.\"), mdx(\"h3\", {\n    \"id\": \"input-validation-and-development\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Input validation and development\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#input-validation-and-development\",\n    \"aria-label\": \"input validation and development permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"style\": {\n      \"paddingLeft\": \"12px\"\n    },\n    \"width\": \"28\",\n    \"height\": \"16\",\n    \"fill\": \"#9f7aea\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"One important aspect when designing custom React Hooks is input validation. We must be able to communicate to developers when things are not running smoothly or a certain use case is hitting an edge case.\"), mdx(\"p\", null, \"Usually, development logs help developers understand unfamiliar code to adjust their implementation. Likewise, we can enhance the above implementation by adding runtime checks and comprehensive warning logs to validate and communicate issues to other developers:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"function useMutationObservable(targetEl, cb, options = DEFAULT_OPTIONS) {\\n  const [observer, setObserver] = useState(null);\\n\\n  useEffect(() => {\\n    // A)\\n    if (!cb || typeof cb !== \\\"function\\\") {\\n      console.warn(`You must provide a valid callback function, instead you've provided ${cb}`);\\n      return;\\n    }\\n    const { debounceTime } = options;\\n    const obs = new MutationObserver(cb);\\n    setObserver(obs);\\n  }, [cb, options, setObserver]);\\n  useEffect(() => {\\n    if (!observer) return;\\n    if (!targetEl) {\\n      // B)\\n      console.warn(`You must provide a valid DOM element to observe, instead you've provided ${targetEl}`);\\n    }\\n    const { config } = options;\\n    try {\\n      observer.observe(targetEl, config);\\n    } catch (e) {\\n      // C)\\n      console.error(e);\\n    }\\n    return () => {\\n      if (observer) {\\n        observer.disconnect();\\n      }\\n    };\\n  }, [observer, targetEl, options]);\\n}\\n\")), mdx(\"p\", null, \"In this example, we\\u2019re checking that a callback is passed as a second argument. This API check at runtime can easily alert the developer that something is wrong on the caller side.\"), mdx(\"p\", null, \"We can also see whether the provided DOM element is invalid with an erroneous value provided to the Hook at runtime or not. These are logged together to inform us to quickly resolve the issue.\"), mdx(\"p\", null, \"And, if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"observe\"), \" throws an error, we can catch and report it. We must avoid breaking the JavaScript runtime flow as much as possible, so by catching the error, we can choose to either log it or report it depending on the environment.\"), mdx(\"h3\", {\n    \"id\": \"extensibility-via-configuration\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Extensibility via configuration\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#extensibility-via-configuration\",\n    \"aria-label\": \"extensibility via configuration permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"style\": {\n      \"paddingLeft\": \"12px\"\n    },\n    \"width\": \"28\",\n    \"height\": \"16\",\n    \"fill\": \"#9f7aea\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"If we want to add more capabilities to our Hook, we should do this in a retro-compatible fashion, such as an opt-in capability that has little or no friction towards its adoption.\"), mdx(\"p\", null, \"Let\\u2019s look at how we can optionally debounce the provided callback function so callers can specify an interval of time when no other changes in the target element trigger. This runs the callback once rather than running the same amount of times the element or its children mutated:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import debounce from \\\"lodash.debounce\\\";\\n\\nconst DEFAULT_OPTIONS = {\\n  config: { attributes: true, childList: true, subtree: true },\\n  debounceTime: 0\\n};\\nfunction useMutationObservable(targetEl, cb, options = DEFAULT_OPTIONS) {\\n  const [observer, setObserver] = useState(null);\\n  useEffect(() => {\\n    if (!cb || typeof cb !== \\\"function\\\") {\\n      console.warn(\\n        `You must provide a valida callback function, instead you've provided ${cb}`\\n      );\\n      return;\\n    }\\n    const { debounceTime } = options;\\n    const obs = new MutationObserver(\\n      debounceTime > 0 ? debounce(cb, debounceTime) : cb\\n    );\\n    setObserver(obs);\\n  }, [cb, options, setObserver]);\\n  // ...\\n\")), mdx(\"p\", null, \"This is handy if we must run a heavy operation, such as triggering a web request, ensuring it runs the minimum number of times possible.\"), mdx(\"p\", null, \"Our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"debounceTime\"), \" option can now pass into our custom Hook. If a value bigger than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \" passes to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MutationObservable\"), \", the callback delays accordingly.\"), mdx(\"p\", null, \"With a simple configuration exposed in our Hook API, we allow other developers to debounce their callbacks which can result in a more performant implementation given that we might drastically reduce the number of times the callback code gets executed.\"), mdx(\"p\", null, \"Of course, we can always debounce the callback on the client side, but this way we enrich our API and make the caller-side implementation smaller and declarative.\"), mdx(\"h3\", {\n    \"id\": \"testing\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Testing\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#testing\",\n    \"aria-label\": \"testing permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"style\": {\n      \"paddingLeft\": \"12px\"\n    },\n    \"width\": \"28\",\n    \"height\": \"16\",\n    \"fill\": \"#9f7aea\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Testing is an essential part of developing any kind of shared capability. It helps us ensure a certain level of quality for generic APIs when they are heavily contributed to and shared.\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.logrocket.com/a-quick-guide-to-testing-react-hooks-fa584c415407/\"\n  }, \"guide to testing React Hooks\"), \" has expansive detail around testing that can be implemented into this tutorial.\"), mdx(\"h3\", {\n    \"id\": \"documentation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Documentation\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#documentation\",\n    \"aria-label\": \"documentation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"style\": {\n      \"paddingLeft\": \"12px\"\n    },\n    \"width\": \"28\",\n    \"height\": \"16\",\n    \"fill\": \"#9f7aea\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Documentation can level up the quality of custom Hooks and make it developer-friendly.\"), mdx(\"p\", null, \"But even when writing plain JavaScript, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://jsdoc.app/\"\n  }, \"JSDoc documentation\"), \" can be written for custom hook APIs to ensure the Hook passes the right message to developers.\"), mdx(\"p\", null, \"Let\\u2019s focus on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMutationObservable\"), \" function declaration and how to add formatted JSDoc documentation to it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"/**\\n  * This custom hooks abstracts the usage of the Mutation Observer with React components.\\n  * Watch for changes being made to the DOM tree and trigger a custom callback.\\n  * @param {Element} targetEl DOM element to be observed\\n  * @param {Function} cb callback that will run when there's a change in targetEl or any\\n  * child element (depending on the provided options)\\n  * @param {Object} options\\n  * @param {Object} options.config check \\\\[options\\\\](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe)\\n  * @param {number} [options.debounceTime=0] a number that represents the amount of time in ms\\n  * that you which to debounce the call to the provided callback function\\n  */\\nfunction useMutationObservable(targetEl, cb, options = DEFAULT_OPTIONS) {\\n\")), mdx(\"p\", null, \"Writing this is not only useful for documentation, but it also leverages IntelliSense capabilities that autocomplete Hook usage and provide spot information for the Hook\\u2019s parameters. This saves developers a few seconds per usage, potentially adding up to hours wasted on reading through the code and trying to understand it.\"), mdx(\"h2\", {\n    \"id\": \"conclusion\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Conclusion\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-label\": \"conclusion permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"style\": {\n      \"paddingLeft\": \"12px\"\n    },\n    \"width\": \"28\",\n    \"height\": \"16\",\n    \"fill\": \"#9f7aea\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"With different kinds of custom Hooks we can implement, we see how they integrate extrinsic APIs into the React world. It\\u2019s easy to integrate state management within Hooks and run effects based on inputs from components using the Hook.\"), mdx(\"p\", null, \"Remember that to build quality Hooks, it\\u2019s important to:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Design easy-to-use, declarative APIs\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Enhance the development experience by checking for proper usage and logging warnings and errors\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Expose features through configurations, such as the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"debounceTime\"), \" example\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ease Hook usage by writing JSDoc documentation\")), mdx(\"p\", null, \"You can check the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codepen.io/danielcaldas/pen/BaWPWEw\"\n  }, \"full implementation of the custom React hook here\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"This article was originally published by  LogRocket . You can checkout the original post  here . With the introduction of React Hooks, the…","timeToRead":4,"banner":null,"parent":{"__typename":"Mdx","frontmatter":{"subtitle":"with MutationObserver"}}}},"pageContext":{"slug":"/blog/guide-to-custom-react-hooks-with-mutationobserver","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}